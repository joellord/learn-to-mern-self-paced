"use strict";(self.webpackChunkswiftui_realm_app=self.webpackChunkswiftui_realm_app||[]).push([[8646],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),l=function(e){var t=r.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return r.createElement(i.Provider,{value:t},e.children)},f="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),f=l(n),d=a,m=f["".concat(i,".").concat(d)]||f[d]||p[d]||o;return n?r.createElement(m,s(s({ref:t},u),{},{components:n})):r.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var c={};for(var i in t)hasOwnProperty.call(t,i)&&(c[i]=t[i]);c.originalType=e,c[f]="string"==typeof e?e:a,s[1]=c;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},1344:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>c,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const o={},s="React useEffect",c={unversionedId:"express-react/effect",id:"express-react/effect",title:"React useEffect",description:"In order to run side effects on components, React provides a hook called useEffect. This hook is called after every render of the component. It can be used to run side effects like fetching data from an API or updating the document title.",source:"@site/docs/8-express-react/3-effect.mdx",sourceDirName:"8-express-react",slug:"/express-react/effect",permalink:"/learn-to-mern-self-paced/docs/express-react/effect",draft:!1,editUrl:"https://github.com/mongodb-developer/learn-to-mern-self-paced/blob/main/docs/8-express-react/3-effect.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"React states",permalink:"/learn-to-mern-self-paced/docs/express-react/state"},next:{title:"Get working",permalink:"/learn-to-mern-self-paced/docs/express-react/get-working"}},i={},l=[],u={toc:l},f="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(f,(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"react-useeffect"},"React useEffect"),(0,a.kt)("p",null,"In order to run side effects on components, React provides a hook called ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect"),". This hook is called after every render of the component. It can be used to run side effects like fetching data from an API or updating the document title."),(0,a.kt)("p",null,"This hook is often used with the ",(0,a.kt)("inlineCode",{parentName:"p"},"useState")," hook to update the state of the component after fetching data from an API."),(0,a.kt)("p",null,"As an example, take this component that will render once, and then change the state after 2 seconds."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},'function App() {\n  const [state, setState] = useState("initial");\n\n  useEffect(() => {\n    setTimeout(() => {\n      setState("updated");\n    }, 2000);\n  }, []);\n\n  return <div>{state}</div>;\n}\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook takes a function as its first argument. This function will be called after every render of the component. The second argument is an array of dependencies. If any of the dependencies change, the function will be called again. If the array is empty, the function will only be called once, after the first render."),(0,a.kt)("p",null,"This can be useful for computed values. For example, if you want to compute the sum of two numbers, you can use the ",(0,a.kt)("inlineCode",{parentName:"p"},"useEffect")," hook to update the sum whenever one of the numbers changes."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx",metastring:"live",live:!0},"function App() {\n  const [a, setA] = useState(0);\n  const [b, setB] = useState(0);\n  const [sum, setSum] = useState(0);\n\n  useEffect(() => {\n    setSum(a + b);\n  }, [a, b]);\n\n  return (\n    <div>\n      <input value={a} onChange={(e) => setA(parseInt(e.target.value))} />\n      <input value={b} onChange={(e) => setB(parseInt(e.target.value))} />\n      <div>{sum}</div>\n    </div>\n  );\n}\n")))}p.isMDXComponent=!0}}]);